{"note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"A flask extension for testing with should-dsl","name":"Flask Should-DSL","body":"This extension adds some basic matchers to should-dsl to allow it to be used\r\neasily along with the standard flask testing setup.\r\n\r\n### Requirements\r\n- Python 2.6, 2.7 or PyPi (others may work, but these are all that's tested)\r\n- [Should-DSL](http://www.should-dsl.info/)\r\n- [Flask](http://flask.pocoo.org/)\r\n\r\n### Installing\r\n\r\nThe recommended way to instal flask is via `pip`:\r\n\r\n    pip install flask-should-dsl\r\n\r\n### Contributing\r\n\r\nTo contribute to flask-should-dsl:\r\n- Create a fork of the repository on github\r\n- Create a feature branch off the develop branch\r\n- Do work\r\n- When you're ready to contribute, create a pull request on github.\r\n\r\nUsage\r\n---\r\n\r\nTo enable the flask-should-dsl matchers, simply import the module:\r\n\r\n```python\r\nimport flask.ext.should_dsl\r\n```\r\n\r\n### Matchers\r\n\r\nThe following matchers are provided by flask-should-dsl:\r\n\r\n##### have_status\r\n\r\nThis checks the status of a response object\r\n\r\n```python\r\n>>> resp.status_code = 200\r\n>>> resp |should| have_status(200)\r\n>>> resp |should| have_status(400)\r\nTraceback (most recent call last):\r\n...\r\nShouldNotSatisfied: Expected the status code 400, but got 200\r\n```\r\n\r\n##### be_xxx / abort_xxx / return_xxx\r\n\r\nThese matchers (be_200, be_400, be_401, be_403, be_404, be_405, be_500) provide\r\nshortcuts to check the status of a response object.  The matchers are avaliable\r\nwith be, abort and return prefixes, to allow for more readable code depending on\r\nthe circumstances\r\n\r\n```python\r\n>>> resp.status_code = 200\r\n>>> resp |should| be_200\r\n>>> resp |should_not| be_200\r\nTraceback (most recent call last):\r\n...\r\nShouldNotSatisfied: Expected the status code not to be 200\r\n>>> app.get('/') |should_not| abort_500\r\n>>> app.get('/') |should_not| return_404\r\n```\r\n\r\n##### redirect_to\r\n\r\nThis matcher checks if a response contains a redirect to another page\r\n\r\n```python\r\n>>> response.status_code = 301\r\n>>> response.location = 'http://localhost/redir'\r\n>>> response |should| redirect_to('/redir')\r\n>>> response.location = 'http://localhost/elsewhere'\r\n>>> response |should| redirect_to('/redir')\r\nTraceback (most recent call last):\r\n...\r\nShouldNotSatisfied: Expected a redirect to \"http://localhost/redir\" but got \"http://localhost/elsewhere\"\r\n>>> response.status_code = 200\r\n>>> response |should| redirect_to('/redir')\r\nTraceback (most recent call last):\r\n...\r\nShouldNotSatisfied: Expected a redirect status, but got 200\r\n```\r\n\r\n##### have_json\r\n\r\nThis matcher checks if a response object contains matching JSON.  \r\n\r\n```python\r\n>>> r.data = json.dumps({'a': 'b'})\r\n>>> r |should| have_json({'a': 'b'})\r\n>>> r |should| have_json({'b': 'c'})\r\nShouldNotSatisfied: Expected response to have json:\r\n\t{'b': 'c'}\r\nbut got:\r\n\t{u'a': u'b'}\r\n```\r\n\r\nIt's also possible to pass in keyword arguments to have_json, which will be\r\nconverted into a dictionary before being compared to the json.\r\n\r\n```python\r\n>>> r |should| have_json(a='b')\r\n>>> r |should| have_json(b='c')\r\nShouldNotSatisfied: Expected response to have json:\r\n\t{'b': 'c'}\r\n```\r\n\r\n##### have_content_type\r\n\r\nThis matcher checks if a response has it's content_type set to a certain value\r\n\r\n```python\r\n>>> r.content_type = 'text/html'\r\n>>> r |should| have_content_type('text/html')\r\n>>> r |should| have_content_type('application/json')\r\nShouldNotSatisfied: Expected content type 'application/json', got 'text/html'\r\n>>> r |should_not| have_content_type('text/html')\r\nShouldNotSatisfied: Expected content type to not be 'text/html'\r\n```\r\n\r\nThis matcher also supports wildcard matches, and if you do not supply both a\r\ntype & a subtype, then it will match on either.\r\n\r\n```python\r\n>>> r.content_type = 'text/html'\r\n>>> r |should| have_content_type('html')\r\n>>> r |should| have_content_type('text')\r\n>>> r |should| have_content_type('text/*')\r\n>>> r |should| have_content_type('*/html')\r\n```\r\n\r\n##### have_header\r\n\r\nThis matcher checks if a response has a header, and optionally checks if that\r\nheader is set to a certain value.\r\n\r\n```python\r\n>>> response |should| have_header('Content-Type')\r\n>>> response |should| have_header('Content-Type')\r\n>>> response |should_not| have_header('X-BadHeader')\r\n>>> response |should_not| have_header('X-BadHeader', 'Something')\r\n>>> response |should_not| have_header('X-BadHeader: Something')\r\n>>> response |should| have_header('Content-Length', '100')\r\nShouldNotSatisfied: Expected header 'Content-Length' to be '100' not '0'\r\n```\r\n","google":""}